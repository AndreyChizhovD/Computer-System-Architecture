# Отчет по ИДЗ-4
# Чижов Андрей Дмитриевич БПИ218
# вариант 14
```
Задача о гостинице - 3 (дамы и джентльмены). 
В гостинице 10 номеров рассчитаны на одного человека и 15 номеров рассчитаны на двух человек. 
В гостиницу случайно приходят клиенты дамы и клиенты джентльмены,
и конечно они могут провести ночь в номере только с представителем своего
пола. Если для клиента не находится подходящего номера, он уходит искать
ночлег в другое место. Клиенты порождаются динамически и уничтожаются
при освобождении номера или уходе из гостиницы при невозможности поселиться. 
Создать многопоточное приложение, моделирующее работу гостиницы.
```
## 7
## C++
## подключенные библиотеки
```cpp
#include <iostream>
#include <vector>
#include <time.h>
#include <pthread.h>
#include <fstream>

```
## определим фигурирующие в задаче объекты и имплементируем вспомогательные структуры
### будем представлять клиента как объект с двумя признаками: пол и номер(имя)
```cpp
using namespace std;

struct Client {
    int sex = 1;
    int number = 0;
};

```
### далее определим два вида комнат в гостинице
### Room1 - одноместная, Room2 - двухместная.
```cpp

struct Room1 {
    Client *client;
};

struct Room2 {
    Client *first_client;
    Client *second_client;
};

```
### будем хранить информацию о комнатах в соответствующих массивах,
### с размерами - задаваемыми параметрами
```cpp

int n, m;
vector<Room1> rooms1 = {};
vector<Room2> rooms2 = {};

```
### так будет генерироваться новопришедший гость
```cpp
Client *createRandomClient() {
    Client *client = new Client;

    int sex = rand() % 2;
    int number = rand() % 100 + 1;

    client->sex = sex;
    client->number = number;

    cout << "client (";
    if (client->sex == 1) {
        cout << "M";
    } else {
        cout << "W";
    }
    cout << ") " << client->number;

    return client;
}
```
### концептуально можно вообразить гостиницу с двумя опциями при заселении - в одноместную или двухместную комнату
### тогда при заселении человек подходит либо к одной стойке, либо к другой
### все это происходит одновременно
### что-то подобное можно реализовать с помощью двух параллельных итеративных потоков, каждый из которых будет "заполнять номера гостиницы" суть массивы
```cpp

    pthread_t thread1;
    pthread_t thread2;

    clock_t start_time = clock();

    if (pthread_create(&thread1, nullptr, thread1_func, nullptr)) {
        return EXIT_FAILURE;
    }

    if (pthread_create(&thread2, nullptr, thread2_func, nullptr)) {
        return EXIT_FAILURE;
    }
    
```
## далее определим функции, которые будем передавать в потоки
### thread_func1 совершает 2n итераций динамического "создания клиента", выводя на экран информацию о заселении или незаселении пришедшего гостя 

```cpp

void *thread1_func(void *) {
    for (int i = 0; i < 2 * n; ++i) {
        func1();
    }
}
```
```cpp

void func1() {
    auto client = createRandomClient();

    if (rooms1.size() == n) {
        cout << " can't take single room because all single rooms are taken.\n";
        delete client;
    } else {
        rooms1.push_back(Room1{client});
        cout << " took single room number " << rooms1.size() << "\n";
    }
}
```
### по аналогии работает thread_func2 за исключением дополнительных проверок
### проверям можно ли заселиться в комнату вторым, т.е. осуществляем проверку на совпадение пола пришедшего и уже живущего в комнате
### 
