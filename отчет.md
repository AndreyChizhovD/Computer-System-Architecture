# Отчет по ИДЗ-1
# Чижов Андрей Дмитриевич БПИ218
# вариант 39

## 4 балла
### Код на языке C
```c
#include <stdio.h>

static int A[1048576];
static int B[1048576];

int main(int argc, char** argv) {
    int n;
    int i;

    scanf("%d", &n);
    for (i = 0; i < n; ++i) {
        scanf("%d", &A[i]);
        
    }

    for (i = 0; i < n; ++i) {
    	B[i] = A[i] * A[i];
    }

    for (i = 0; i < n; ++i) {
    	printf("%d", B[i]);
    }

    return 0;
}
```

### Компиляция программы
```sh
gcc -masm=intel -S v39.c -o v39.s
```

### Программа на ассемблере
```assembly
    .file	"v39.c"
	.intel_syntax noprefix			# синтаксис в стиле Intel
	.text					# начало секции
	.local	A				# объявление символа A
	.comm	A,4194304,32			# неинициализированный массив А
	.local	B				# тоже самое с массивом В
	.comm	B,4194304,32			
	.section	.rodata			# переход в секцию  .rodata
.LC0:
	.string	"%d"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	endbr64
	push	rbp				# rbp сохранен на стек
	.cfi_def_cfa_offset 16			
	.cfi_offset 6, -16
	mov	rbp, rsp
	.cfi_def_cfa_register 6			# rbp := rsp
	sub	rsp, 32				# rsp -= 32
	mov	DWORD PTR -20[rbp], edi		# argc
	mov	QWORD PTR -32[rbp], rsi		# argv
	mov	rax, QWORD PTR fs:40		
	mov	QWORD PTR -8[rbp], rax		# n
	xor	eax, eax			
	lea	rax, -16[rbp] 			# rax(n) := &(-16 на стеке) 
	mov	rsi, rax
	lea	rax, .LC0[rip]
	mov	rdi, rax
	mov	eax, 0				# счетчик в цикле
	call	__isoc99_scanf@PLT		# вызов scanf 
	mov	DWORD PTR -12[rbp], 0		
	jmp	.L2				# прыгаем по меткам в цикле
.L3:						
	mov	eax, DWORD PTR -12[rbp]
	cdqe
	lea	rdx, 0[0+rax*4]
	lea	rax, A[rip]
	add	rax, rdx
	mov	rsi, rax
	lea	rax, .LC0[rip]
	mov	rdi, rax
	mov	eax, 0
	call	__isoc99_scanf@PLT
	add	DWORD PTR -12[rbp], 1
.L2:
	mov	eax, DWORD PTR -16[rbp]
	cmp	DWORD PTR -12[rbp], eax
	jl	.L3
	mov	DWORD PTR -12[rbp], 0
	jmp	.L4
.L5:
	mov	eax, DWORD PTR -12[rbp]
	cdqe
	lea	rdx, 0[0+rax*4]
	lea	rax, A[rip]
	mov	edx, DWORD PTR [rdx+rax]
	mov	eax, DWORD PTR -12[rbp]
	cdqe
	lea	rcx, 0[0+rax*4]
	lea	rax, A[rip]
	mov	eax, DWORD PTR [rcx+rax]
	imul	eax, edx
	mov	edx, DWORD PTR -12[rbp]
	movsx	rdx, edx
	lea	rcx, 0[0+rdx*4]
	lea	rdx, B[rip]
	mov	DWORD PTR [rcx+rdx], eax
	add	DWORD PTR -12[rbp], 1
.L4:
	mov	eax, DWORD PTR -16[rbp]
	cmp	DWORD PTR -12[rbp], eax
	jl	.L5
	mov	DWORD PTR -12[rbp], 0
	jmp	.L6
.L7:
	mov	eax, DWORD PTR -12[rbp]
	cdqe
	lea	rdx, 0[0+rax*4]
	lea	rax, B[rip]
	mov	eax, DWORD PTR [rdx+rax]
	mov	esi, eax
	lea	rax, .LC0[rip]
	mov	rdi, rax
	mov	eax, 0
	call	printf@PLT
	add	DWORD PTR -12[rbp], 1
.L6:
	mov	eax, DWORD PTR -16[rbp]
	cmp	DWORD PTR -12[rbp], eax
	jl	.L7
	mov	eax, 0
	mov	rdx, QWORD PTR -8[rbp]
	sub	rdx, QWORD PTR fs:40
	je	.L9
	call	__stack_chk_fail@PLT
.L9:							# Выход из функции
	leave					
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
```

```sh
gcc ./v39.s -o ./v39.exe \
    ./v39.exe
***test***
```


### Компиляция программы с оптимизацией
```sh
gcc -masm=intel \
    -fno-asynchronous-unwind-tables \
    -fno-jump-tables \
    -fno-stack-protector \
    -fno-exceptions \
    ./v39.c \
    -S -o ./v39.s
```

### Тесты

| input  | output v39.c            | output v39.s           |
|-----------------|:---------------:|:---------------:|
| 0 | - | - |
| 5 [1 2 3 4 5]       | [1 4 9 16 25]     | [1 4 9 16 25]     |
| 4 [0 9 10 3]    | [0 81 100 9] | [0 81 100 9] |
| 5 [13 11 0 4 1]| [169 121 0 16 1]|[169 121 0 16 1]|
